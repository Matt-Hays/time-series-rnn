class TrainModel:
    """
    Trains a Recurrent Neural Network (RNN) model on a given dataset.

    Methods:
        preprocess_data():
            Preprocesses the data.
        define_window():
            Defines the window for the model.
        compile_and_fit():
            Compiles and fits the model.
        train_model():
            Trains the model.
        evaluate_model():
            Evaluates the model.
        compile_and_save():
            Compiles and saves the model.
        plot_model_validation():
            Plots the model validation.

    See Also:
        - `PredictFuture`: Executes a prediction using the RNN model generated by this class and a given dataset that is
        shaped in the same way as the dataset used to train the model. NOTE: It is the resonsibility of the user to ensure
        that the appropriate data shapes and window sizes are selected when matching a model to a dataset.
    """

    def __init__(
        self,
        model_name,
        csv_path,
        save_path,
        tf,
        pd,
        WindowGenerator,
        Baseline,
        IPython,
        MAX_EPOCHS,
    ):
        """
        Args:
            model_name (str):
                The name of the model to be trained.
            csv_path (str):
                The relative path to the dataset.
            save_path (str):
                The relative path to save the model.
            tf (module):
                The TensorFlow module.
            pd (module):
                The Pandas module.
            WindowGenerator (class):
                The WindowGenerator class from WindowGenerator.py.
            Baseline (class):
                The Baseline class from Baseline.py.
            IPython (module):
                The IPython module.
            MAX_EPOCHS (int):
                The maximum number of epochs to train the model for.

        Returns:
            `TrainModel` object.
        """

        self.model_name = model_name
        self.csv_path = csv_path
        self.save_path = save_path
        self.tf = tf
        self.pd = pd
        self.window_generator = WindowGenerator
        self.baseline = Baseline
        self.iPython = IPython
        self.MAX_EPOCHS = MAX_EPOCHS

        self.train_df = None
        self.val_df = None
        self.test_df = None
        self.wide_window = None
        self.lstm_model = None
        self.history = None

        self.val_performance = {}
        self.performance = {}

        self.df = pd.read_csv(self.csv_path)
        self.preprocess_data()

    def preprocess_data(self):
        """
        Removes the csv header row and the "Date" column from the dataset.
        Determines the training, validation, and testing datasets as 70%, 20%, and 10% respectively.
        Normalizes the datasets by subtracting the mean and dividing by the standard deviation.

        Args:
            None

        Returns:
            None
        """

        self.df = self.df[1:]
        self.df.pop("Date")

        n = len(self.df)
        self.train_df = self.df[0 : int(n * 0.7)]
        self.val_df = self.df[int(n * 0.7) : int(n * 0.9)]
        self.test_df = self.df[int(n * 0.9) :]

        train_mean = self.train_df.mean()
        train_std = self.train_df.std()
        self.train_df = (self.train_df - train_mean) / train_std
        self.val_df = (self.val_df - train_mean) / train_std
        self.test_df = (self.test_df - train_mean) / train_std

    def define_window(self, window_size=30):
        """
        Defines a sliding window used to train the RNN model.

        Args:
            - window_size (int): The size of the window.

        Returns:
            None
        """

        window_width = window_size
        self.wide_window = self.window_generator(
            input_width=window_width,
            label_width=window_width,
            shift=1,
            train_df=self.train_df,
            val_df=self.val_df,
            test_df=self.test_df,
            label_columns=["Close"],
        )

    def compile_and_fit(self, model, window, patience=10):
        """
        Provides the model with the necessary parameters to compile and fit the model.
        Early stopping is used to assit in preventing overfitting of the model.
        This method is intended to be iterated upon to iterate to an optimal model over X number of epochs (iterations).

        Args:
            - model (tf.keras.models.Sequential): The model to be compiled and fit.
            - window (WindowGenerator): The window used to train the model.
            - patience (int): The number of epochs to wait before stopping the model if no improvement is made.

        Returns:
            None
        """

        early_stopping = self.tf.keras.callbacks.EarlyStopping(
            monitor="mean_absolute_error",
            min_delta=1e-6,
            patience=patience,
            mode="auto",
            verbose=1,
        )

        model.compile(
            loss=self.tf.keras.losses.MeanSquaredError(),
            optimizer=self.tf.keras.optimizers.legacy.Adam(),
            metrics=[self.tf.keras.metrics.MeanAbsoluteError()],
        )

        self.history = model.fit(
            window.train,
            epochs=self.MAX_EPOCHS,
            validation_data=window.val,
            callbacks=[early_stopping],
        )

    def train_model(self):
        """
        Trains the model using the `compile_and_fit` method, the `wide_window` window, and the `lstm_model` model.
        Executes compilation and fitting of the model.

        Args:
            None

        Returns:
            None
        """

        self.lstm_model = self.tf.keras.models.Sequential(
            [
                # Shape [batch, time, features] => [batch, time, lstm_units]
                self.tf.keras.layers.LSTM(32, return_sequences=True),
                # Shape => [batch, time, features]
                self.tf.keras.layers.Dense(units=1),
            ]
        )
        self.history = self.compile_and_fit(self.lstm_model, self.wide_window)

    def evaluate_model(self):
        self.iPython.display.clear_output()
        self.val_performance["LSTM"] = self.lstm_model.evaluate(self.wide_window.val)
        self.performance["LSTM"] = self.lstm_model.evaluate(
            self.wide_window.test, verbose=0
        )

    def compile_and_save(self):
        self.lstm_model.compile(
            optimizer=self.tf.keras.optimizers.legacy.Adam(), loss="mse"
        )
        self.lstm_model.save(self.save_path)

    def plot_model_validation(self):
        self.wide_window.plot(self.lstm_model)
